// This software is in the public domain.
//
// The software is provided "as is", without warranty of any kind,
// express or implied, including but not limited to the warranties
// of merchantability, fitness for a particular purpose, and
// noninfringement. In no event shall the author(s) be liable for any
// claim, damages, or other liability, whether in an action of
// contract, tort, or otherwise, arising from, out of, or in connection
// with the software or the use or other dealings in the software.
//
// This software was originally developed at the Technical University
// of Darmstadt, Germany.

// Version 2.0
// Changes from version 1.0:
// * Changed Column.number to Column.rowObjectIndex.
// * Modified constructor for new name.
// Changes from version 1.01: Complete rewrite.

package org.xmlmiddleware.xmldbms.maps;

import java.sql.Types;
import java.sql.DatabaseMetaData;
import java.text.DateFormat;
import java.text.Format;
import java.text.NumberFormat;

import org.xmlmiddleware.utils.JDBCTypes;

/**
 * Describes a column; <a href="../readme.html#NotForUse">not for general
 * use</a>.
 *
 * <p>Column contains information about a column. The column metadata (type,
 * length, nullability, etc.) can be set from a database or from a map
 * document. Columns are stored in Tables, PropertyMaps, PropertyTableMaps,
 * OrderInfos, and Keys.</p>
 *
 * <p>Note that column values are stored in three separate objects
 * in XML-DBMS:</p>
 * 
 * <ul>
 * <li><b>Result sets:</b> These are JDBC ResultSet objects either passed
 * to DBMSToDOM or generated by DBMSToDOM when transferring data from the
 * database to XML.</li>
 *
 * <li><b>Row object:</b> This is an intermediate object used by both
 * DBMSToDOM and DOMToDBMS to buffer column values.</li>
 *
 * <li><b>INSERT statement:</b> These are JDBC PreparedStatement objects
 * created by DOMToDBMS when transferring data from XML to the database.</li>
 * </ul>
 *
 * <p>The position of a column value can be different in each of these
 * three objects. For example, it could be in column 5 in the result set,
 * array index 3 in the Row object, and parameter 4 in the INSERT
 * statement. Thus, three sets of column numbers are needed:</p>
 *
 * <ul>
 * <li><b>Result set column number:</b> This is the number of the column in
 * the result set in which the value is stored. The number is 1-based and is
 * stored in the Table.rsColumnNumbers array. (Note that the order in which
 * result set column numbers are stored in this array guarantees that columns
 * in the result set will be accessed in increasing order.)</li>
 *
 * <li><b>Row object column number:</b> This is the index of the position in
 * the Row.columnValues array in which the value is stored. The index is
 * 0-based and is stored in the rowObjectIndex variable of Column. It is
 * also the index of the Table.rsColumnNumbers array; that is, column values
 * are stored in the Row object in the same order they occur in the result
 * set. In XML-DBMS version 1.0, this was named Column.number.</li>
 *
 * <li><b>INSERT statement parameter number:</b> This is the number of the
 * parameter in the INSERT statement in which the column value is stored. The
 * number is 1-based and corresponds to the order in which the Column object is
 * stored in the Table.columns array; it is therefore not stored separately.</li>
 * </ul>
 *
 * <p>In virtually all cases, these three column numbers are the same, except for
 * differences due to being 0- or 1-based. This is because XML-DBMS generates
 * SELECT and INSERT statements itself and therefore places the columns in the
 * same order in each. The only time that they differ is when the calling
 * application passes a result set to DBMSToDOM.retrieveDocument. In this case,
 * the number <i>and</i> order of columns in the result set can differ from the
 * order of the columns as they appear in the Table.columns array. Because of
 * this, the three different numbers are needed.</p>
 *
 * <p>In the future, the Column class should contain information about the
 * nullability and data type of the column as well. This will be used when creating
 * CREATE TABLE statements.</p>
 *
 * @author Ronald Bourret, 1998-1999, 2001
 * @version 2.0
 */

public class Column extends MapBase
{
   // ********************************************************************
   // Private variables
   // ********************************************************************

   private String name = null;

   private int resultSetIndex = -1;
   private int rowIndex = -1;
   private int parameterIndex = -1;
   private int type = Types.NULL;
   private int length = -1;
   private int precision = -1;
   private int scale = Integer.MIN_VALUE;
   private int nullability = DatabaseMetaData.columnNullableUnknown;
   private Format format = null;

   private boolean defaultFormat = true;
   private String formatName = null;

   // ********************************************************************
   // Constructors
   // ********************************************************************

   private Column(String name)
   {
      this.name = name;
   }

   // ********************************************************************
   // Factory methods
   // ********************************************************************

   /**
    * Create a new column.
    *
    * @param columnName Name of the column.
    *
    * @return The column.
    */
   public static Column create(String columnName)
   {
      checkArgNull(columnName, ARG_COLUMNNAME);
      return new Column(columnName);
   }

   // ********************************************************************
   // Accessors and mutators
   // ********************************************************************

   // ********************************************************************
   // Name
   // ********************************************************************

   /**
    * Get the column name.
    *
    * @return The column name.
    */
   public final String getName()
   {
      return name;
   }

   // ********************************************************************
   // Row, result set, and parameter index
   // ********************************************************************

   /**
    * Get the row index.
    *
    * <p>This is the index of the column value in the Rows.columnValues
    * array. 0-based.</p>
    *
    * @return The row index.
    */
   public final int getRowIndex()
   {
      return rowIndex;
   }

   /**
    * Set the row index.
    *
    * <p>This is the index of the column value in the Rows.columnValues
    * array. 0-based.</p>
    *
    * @param index The row index.
    */
   public void setRowIndex(int index)
   {
      if (index < 0)
         throw new IllegalArgumentException("Row index must be >= 0");
      rowIndex = index;
   }

   /**
    * Get the result set index.
    *
    * <p>This is the index of the column value in the ResultSet. 1-based.</p>
    *
    * @return The result set index.
    */
   public final int getResultSetIndex()
   {
      return resultSetIndex;
   }

   /**
    * Set the result set index.
    *
    * <p>This is the index of the column value in a JDBC ResultSet. 1-based.</p>
    *
    * @param index The result set index.
    */
   public void setResultSetIndex(int index)
   {
      if (index < 1)
         throw new IllegalArgumentException("Result set index must be >= 1");
      resultSetIndex = index;
   }

   /**
    * Get the parameter index.
    *
    * <p>This is the index of the column value in a JDBC INSERT PreparedStatement.
    * 1-based.</p>
    *
    * @return The parameter index.
    */
   public final int getParameterIndex()
   {
      return parameterIndex;
   }

   /**
    * Set the parameter index.
    *
    * <p>This is the index of the column value in a JDBC INSERT PreparedStatement.
    * 1-based.</p>
    *
    * @param index The parameter index.
    */
   public void setParameterIndex(int index)
   {
      if (index < 1)
         throw new IllegalArgumentException("Parameter index must be >= 1");
      parameterIndex = index;
   }

   // ********************************************************************
   // Type
   // ********************************************************************

   /**
    * Get the column type.
    *
    * <p>This is one of the types in the JDBC Types class.</p>
    *
    * @return The column type.
    */
   public final int getType()
   {
      return type;
   }

   /**
    * Set the column type.
    *
    * <p>This is one of the types in the JDBC Types class. If the type is
    * not binary or character, this method sets the length to -1.</p>
    *
    * @param type The column type.
    */
   public void setType(int type)
   {
      if (!JDBCTypes.typeIsValid(type))
         throw new IllegalArgumentException("Invalid JDBC type: " + type);

      // If the format is not the default format -- that is, the format has been
      // explicitly set -- check that the format type is legal for the new data
      // type.

      if (!defaultFormat)
      {
         if ((format instanceof DateFormat) && !JDBCTypes.typeIsDateTime(type))
            throw new IllegalArgumentException("Format is a DateFormat and type is not a date/time type.");
         else if ((format instanceof NumberFormat) && !JDBCTypes.typeIsNumeric(type))
            throw new IllegalArgumentException("Format is a NumberFormat and type is not a numeric type.");
      }

      // If the new type is not a character or binary type, set the length to -1.

      if (!JDBCTypes.typeIsChar(type) && !JDBCTypes.typeIsBinary(type))
      {
         this.length = -1;
      }

      // If the new type is not DECIMAL or NUMBER, set the precision and scale to
      // invalid values.

      if ((type != Types.DECIMAL) && (type != Types.NUMERIC))
      {
         this.precision = -1;
         this.scale = Integer.MIN_VALUE;
      }

      // Set the new type.

      this.type = type;
   }

   // ********************************************************************
   // Length
   // ********************************************************************

   /**
    * Get the column length.
    *
    * <p>This method should only be called for character and binary types.
    * The return value is undefined for other types.</p>
    *
    * @return The column length. This is -1 if the length is not set.
    */
   public final int getLength()
   {
      return length;
   }

   /**
    * Set the column length.
    *
    * <p>This method may only be called for character and binary types.</p>
    *
    * @return The column length.
    */
   public void setLength(int length)
   {
      if (!JDBCTypes.typeIsChar(type) || JDBCTypes.typeIsBinary(type))
         throw new IllegalStateException("setLength may be called only for columns with a character or binary type.");
      if (length < 1)
         throw new IllegalArgumentException("Length must be >= 1");
      this.length = length;
   }

   // ********************************************************************
   // Precision
   // ********************************************************************

   /**
    * Get the column precision.
    *
    * <p>This method should only be called for DECIMAL and NUMERIC types.
    * The return value is undefined for other types.</p>
    *
    * @return The column precision.
    */
   public final int getPrecision()
   {
      return precision;
   }

   /**
    * Set the column precision.
    *
    * <p>This method may only be called for DECIMAL and NUMERIC types.</p>
    *
    * @return The column precision.
    */
   public void setPrecision(int precision)
   {
      if ((type != Types.DECIMAL) && (type != Types.NUMERIC))
         throw new IllegalStateException("setPrecision may be called only for columns with a DECIMAL or NUMERIC type.");
      if (precision < 1)
         throw new IllegalArgumentException("Precision must be >= 1");
      this.precision = precision;
   }

   // ********************************************************************
   // Scale
   // ********************************************************************

   /**
    * Get the column scale.
    *
    * <p>This method should only be called for DECIMAL and NUMERIC types.
    * The return value is undefined for other types.</p>
    *
    * @return The column scale.
    */
   public final int getScale()
   {
      return scale;
   }

   /**
    * Set the column scale.
    *
    * <p>This method may only be called for DECIMAL and NUMERIC types.</p>
    *
    * @return The column scale.
    */
   public void setScale(int scale)
   {
      if ((type != Types.DECIMAL) && (type != Types.NUMERIC))
         throw new IllegalStateException("setScale may be called only for columns with a DECIMAL or NUMERIC type.");
      this.scale = scale;
   }

   // ********************************************************************
   // Nullability
   // ********************************************************************

   /**
    * Whether the column is nullable.
    *
    * @return DatabaseMetaData.columnNullableUnknown, .columnNullable, or .columnNoNulls.
    */
   public final int getNullability()
   {
      return nullability;
   }

   /**
    * Set whether the column is nullable.
    *
    * @param nullability DatabaseMetaData.columnNullableUnknown, .columnNullable,
    *    or .columnNoNulls.
    */
   public void setNullability(int nullability)
   {
      if ((nullability != DatabaseMetaData.columnNullableUnknown) &&
          (nullability != DatabaseMetaData.columnNullable) &&
          (nullability != DatabaseMetaData.columnNoNulls))
         throw new IllegalArgumentException("Invalid nullability value: " + nullability);
      this.nullability = nullability;
   }

   // ********************************************************************
   // Format
   // ********************************************************************

   /**
    * Get the column format.
    *
    * <p>This method returns a DateFormat or NumberFormat object. The calling method
    * must determine the class of the returned object.</p>
    *
    * @return The format. May be null.
    */
   public final Format getFormat()
   {
      return format;
   }

   /**
    * Set the column format.
    *
    * @param format The format. If this is null, the default format for
    *    the column type will be used.
    */
   public void setFormat(Format format)
   {
      // Formats can only be set when the type is NULL (not yet set), date/time,
      // or numeric.

      if ((type != Types.NULL) && !JDBCTypes.typeIsDateTime(type) && !JDBCTypes.typeIsNumeric(type))
         throw new IllegalStateException("Formats may only be set for date, time, timestamp, and numeric columns.");

      // If the format is null, use the default format.

      if (format == null)
      {
         this.defaultFormat = true;
         this.format = null;
         return;
      }

      // If the format is not null, check that it is:
      // a) A DateFormat or a NumberFormat, and
      // b) Appropriate for the type (if the type is set).

      if (format instanceof DateFormat)
      {
         if ((type != Types.NULL) && (!JDBCTypes.typeIsDateTime(type)))
            throw new IllegalArgumentException("Format is a DateFormat and the column type is not a date/time type.");
      }
      else if (format instanceof NumberFormat)
      {
         if ((type != Types.NULL) && (!JDBCTypes.typeIsNumeric(type)))
            throw new IllegalArgumentException("Format is a NumberFormat and the column type is not a numeric type.");
      }
      else
         throw new IllegalArgumentException("Format must be a DateFormat or a NumberFormat.");

      // Set the new format and note that this is not the default format.

      this.format = format;
      this.defaultFormat = false;
   }

   /**
    * Whether a column uses the default format.
    *
    * <p>The default format is the date, time, datetime, or number format
    * appropriate for the data type. This is the default specified through
    * Map.addXxxxFormat or the system format if no default has been specified.</p>
    *
    * <p>The column uses a default format if no format has been explicitly set
    * or the format has been set to null. Note that if Map.setDefaultFormats()
    * has been called, getFormat() returns the default format if no format has
    * been explicitly set.</p>
    *
    * @return Whether a column uses the default format.
    */
   public final boolean useDefaultFormat()
   {
      return defaultFormat;
   }

   // ********************************************************************
   // Package methods
   // ********************************************************************

   void setDefaultFormat(Format format)
   {
      // This method is called by Map.setDefaultFormats() to set the appropriate
      // format for the column. It assumes that the type is not Types.NULL and that
      // this.defaultFormat is true.
 
      this.format = format;
   }
}